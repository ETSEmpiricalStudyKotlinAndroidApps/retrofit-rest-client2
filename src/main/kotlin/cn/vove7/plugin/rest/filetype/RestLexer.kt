/* The following code was generated by JFlex 1.7.0 tweaked for IntelliJ platform */
package cn.vove7.plugin.rest.filetype

import com.intellij.lexer.FlexLexer
import cn.vove7.plugin.rest.filetype.RestLexer
import java.io.IOException
import java.lang.ArrayIndexOutOfBoundsException
import com.intellij.psi.tree.IElementType
import cn.vove7.plugin.rest.psi.RestTypes
import java.io.Reader
import java.lang.Error

/**
 * This class is a scanner generated by
 * [JFlex](http://www.jflex.de/) 1.7.0
 * from the specification file <tt>Rest.flex</tt>
 */
internal class RestLexer
/**
 * Creates a new scanner
 *
 * @param   in  the java.io.Reader to read input from.
 */(
    /** the input device  */
    private val zzReader: Reader?
) : FlexLexer {
    /** the current state of the DFA  */
    private var zzState = 0

    /** the current lexical state  */
    private var zzLexicalState = YYINITIAL

    /** this buffer contains the current text to be matched and is
     * the source of the yytext() string  */
    private var zzBuffer: CharSequence = ""

    /** the textposition at the last accepting state  */
    private var zzMarkedPos = 0

    /** the current text position in the buffer  */
    private var zzCurrentPos = 0

    /** startRead marks the beginning of the yytext() string in the buffer  */
    private var zzStartRead = 0

    /** endRead marks the last character in the buffer, that has been read
     * from input  */
    private var zzEndRead = 0

    /**
     * zzAtBOL == true <=> the scanner is currently at the beginning of a line
     */
    private var zzAtBOL = true

    /** zzAtEOF == true <=> the scanner is at the EOF  */
    private var zzAtEOF = false

    /** denotes if the user-EOF-code has already been executed  */
    private var zzEOFDone = false
    override fun getTokenStart(): Int {
        return zzStartRead
    }

    override fun getTokenEnd(): Int {
        return tokenStart + yylength()
    }

    override fun reset(buffer: CharSequence, start: Int, end: Int, initialState: Int) {
        zzBuffer = buffer
        zzStartRead = start
        zzMarkedPos = zzStartRead
        zzCurrentPos = zzMarkedPos
        zzAtEOF = false
        zzAtBOL = true
        zzEndRead = end
        yybegin(initialState)
    }

    /**
     * Refills the input buffer.
     *
     * @return      `false`, iff there was new input.
     *
     * @exception   java.io.IOException  if any I/O-Error occurs
     */
    @Throws(IOException::class)
    private fun zzRefill(): Boolean {
        return true
    }

    /**
     * Returns the current lexical state.
     */
    override fun yystate(): Int {
        return zzLexicalState
    }

    /**
     * Enters a new lexical state
     *
     * @param newState the new lexical state
     */
    override fun yybegin(newState: Int) {
        zzLexicalState = newState
    }

    /**
     * Returns the text matched by the current regular expression.
     */
    fun yytext(): CharSequence {
        return zzBuffer.subSequence(zzStartRead, zzMarkedPos)
    }

    /**
     * Returns the character at position `pos` from the
     * matched text.
     *
     * It is equivalent to yytext().charAt(pos), but faster
     *
     * @param pos the position of the character to fetch.
     * A value from 0 to yylength()-1.
     *
     * @return the character at position pos
     */
    fun yycharat(pos: Int): Char {
        return zzBuffer[zzStartRead + pos]
    }

    /**
     * Returns the length of the matched text region.
     */
    fun yylength(): Int {
        return zzMarkedPos - zzStartRead
    }

    /**
     * Reports an error that occurred while scanning.
     *
     * In a wellformed scanner (no or only correct usage of
     * yypushback(int) and a match-all fallback rule) this method
     * will only be called with things that "Can't Possibly Happen".
     * If this method is called, something is seriously wrong
     * (e.g. a JFlex bug producing a faulty scanner etc.).
     *
     * Usual syntax/scanner level error handling should be done
     * in error fallback rules.
     *
     * @param   errorCode  the code of the errormessage to display
     */
    private fun zzScanError(errorCode: Int) {
        val message: String
        message = try {
            ZZ_ERROR_MSG[errorCode]
        } catch (e: ArrayIndexOutOfBoundsException) {
            ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR]
        }
        throw Error(message)
    }

    /**
     * Pushes the specified amount of characters back into the input stream.
     *
     * They will be read again by then next call of the scanning method
     *
     * @param number  the number of characters to be read again.
     * This number must not be greater than yylength()!
     */
    fun yypushback(number: Int) {
        if (number > yylength()) zzScanError(ZZ_PUSHBACK_2BIG)
        zzMarkedPos -= number
    }

    /**
     * Contains user EOF-code, which will be executed exactly once,
     * when the end of file is reached
     */
    private fun zzDoEOF() {
        if (!zzEOFDone) {
            zzEOFDone = true
        }
    }

    /**
     * Resumes scanning until the next regular expression is matched,
     * the end of input is encountered or an I/O-Error occurs.
     *
     * @return      the next token
     * @exception   java.io.IOException  if any I/O-Error occurs
     */
    @Throws(IOException::class)
    override fun advance(): IElementType? {
        var zzInput: Int=0
        var zzAction: Int=0

        // cached fields:
        var zzCurrentPosL: Int
        var zzMarkedPosL: Int
        var zzEndReadL = zzEndRead
        var zzBufferL = zzBuffer
        val zzTransL = ZZ_TRANS
        val zzRowMapL = ZZ_ROWMAP
        val zzAttrL = ZZ_ATTRIBUTE
        while (true) {
            zzMarkedPosL = zzMarkedPos
            zzAction = -1
            zzStartRead = zzMarkedPosL
            zzCurrentPos = zzStartRead
            zzCurrentPosL = zzCurrentPos
            zzState = ZZ_LEXSTATE[zzLexicalState]

            // set up zzAction for empty match case:
            var zzAttributes = zzAttrL[zzState]
            if (zzAttributes and 1 == 1) {
                zzAction = zzState
            }
                while (true) {
                    if (zzCurrentPosL < zzEndReadL) {
                        zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL /*, zzEndReadL*/)
                        zzCurrentPosL += Character.charCount(zzInput)
                    } else if (zzAtEOF) {
                        zzInput = YYEOF
                        break
                    } else {
                        // store back cached positions
                        zzCurrentPos = zzCurrentPosL
                        zzMarkedPos = zzMarkedPosL
                        val eof = zzRefill()
                        // get translated positions and possibly new buffer
                        zzCurrentPosL = zzCurrentPos
                        zzMarkedPosL = zzMarkedPos
                        zzBufferL = zzBuffer
                        zzEndReadL = zzEndRead
                        if (eof) {
                            zzInput = YYEOF
                            break
                        } else {
                            zzInput = Character.codePointAt(zzBufferL, zzCurrentPosL /*, zzEndReadL*/)
                            zzCurrentPosL += Character.charCount(zzInput)
                        }
                    }
                    val zzNext = zzTransL[zzRowMapL[zzState] + ZZ_CMAP(zzInput)]
                    if (zzNext == -1) break
                    zzState = zzNext
                    zzAttributes = zzAttrL[zzState]
                    if (zzAttributes and 1 == 1) {
                        zzAction = zzState
                        zzMarkedPosL = zzCurrentPosL
                        if (zzAttributes and 8 == 8) break
                    }
                }


            // store back cached position
            zzMarkedPos = zzMarkedPosL
            if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
                zzAtEOF = true
                zzDoEOF()
                return null
            } else {
                when (if (zzAction < 0) zzAction else ZZ_ACTION[zzAction]) {
                    1 -> {
                        yybegin(S_URL)
                        return RestTypes.URL
                    }
                    16 -> {}
                    2 -> {
                        return RestTypes.COMMENT
                    }
                    17 -> {}
                    3 -> {
                        return RestTypes.CRLF
                    }
                    18 -> {}
                    4 -> {
                        return RestTypes.WHITE_SPACE
                    }
                    19 -> {}
                    5 -> {
                        yybegin(S_REQ_BODY)
                        return RestTypes.REQUEST_BODY_LINE
                    }
                    20 -> {}
                    6 -> {
                        yybegin(S_REQ_HEADER)
                        return RestTypes.HEADER
                    }
                    21 -> {}
                    7 -> {
                        yybegin(S_PARAM)
                        return RestTypes.PARAM
                    }
                    22 -> {}
                    8 -> {
                        return RestTypes.PARAM
                    }
                    23 -> {}
                    9 -> {
                        return RestTypes.HEADER
                    }
                    24 -> {}
                    10 -> {
                        yybegin(S_RESP_BODY)
                        return RestTypes.RESPONSE_BODY_LINE
                    }
                    25 -> {}
                    11 -> {
                        return RestTypes.RESPONSE_BODY_LINE
                    }
                    26 -> {}
                    12 -> {
                        yybegin(S_OPTION)
                        return RestTypes.OPTION
                    }
                    27 -> {}
                    13 -> {
                        return RestTypes.OPTION
                    }
                    28 -> {}
                    14 -> {
                        yybegin(S_METHOD)
                        return RestTypes.METHOD
                    }
                    29 -> {}
                    15 -> {
                        yybegin(S_RESP_HEADER)
                        return RestTypes.SEPARATOR
                    }
                    30 -> {}
                    else -> zzScanError(ZZ_NO_MATCH)
                }
            }
        }
    }

    companion object {
        /** This character denotes the end of file  */
        const val YYEOF = -1

        /** initial size of the lookahead buffer  */
        private const val ZZ_BUFFERSIZE = 16384

        /** lexical states  */
        const val YYINITIAL = 0
        const val S_METHOD = 2
        const val S_OPTION = 4
        const val S_URL = 6
        const val S_PARAM = 8
        const val S_REQ_HEADER = 10
        const val S_RESP_HEADER = 12
        const val S_RESP_BODY = 14
        const val S_REQ_BODY = 16

        /**
         * ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l
         * ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l
         * at the beginning of a line
         * l is of the form l = 2*k, k a non negative integer
         */
        private val ZZ_LEXSTATE = intArrayOf(
            0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7,
            8, 8
        )

        /**
         * Translates characters to character classes
         * Chosen bits are [8, 6, 7]
         * Total runtime size is 1040 bytes
         */
        fun ZZ_CMAP(ch: Int): Int {
            return ZZ_CMAP_A[ZZ_CMAP_Y[ZZ_CMAP_Z[ch shr 13].toInt() or (ch shr 7 and 0x3f)].toInt() or (ch and 0x7f)]
                .toInt()
        }

        /* The ZZ_CMAP_Z table has 136 entries */
        val ZZ_CMAP_Z = zzUnpackCMap(
            "\u0001\u0000\u0087\u0040"
        )

        /* The ZZ_CMAP_Y table has 128 entries */
        val ZZ_CMAP_Y = zzUnpackCMap(
            "\u0001\u0000\u007f\u0080"
        )

        /* The ZZ_CMAP_A table has 256 entries */
        val ZZ_CMAP_A = zzUnpackCMap(
            """	      
  	 
   ª """
        )

        /**
         * Translates DFA states to action switch labels.
         */
        private val ZZ_ACTION = zzUnpackAction()
        private const val ZZ_ACTION_PACKED_0 =
            "\u0009\u0000\u0005\u0001\u0001\u0002\u0002\u0003\u0001\u0004\u0001\u0001\u0001\u0005\u0001\u0006" +
                    "\u0001\u0007\u0001\u0004\u0001\u0005\u0001\u0008\u0001\u0009\u0001\u000a\u0001\u0004\u0001\u000b" +
                    "\u0004\u0001\u0001\u000c\u0001\u000d\u0001\u0000\u0001\u0005\u0001\u000e\u0002\u0001\u0001\u0000" +
                    "\u0001\u000f\u0002\u0001\u0001\u000f\u0001\u0001"

        private fun zzUnpackAction(): IntArray {
            val result = IntArray(46)
            var offset = 0
            offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result)
            return result
        }

        private fun zzUnpackAction(packed: String, offset: Int, result: IntArray): Int {
            var i = 0 /* index in packed string  */
            var j = offset /* index in unpacked array */
            val l = packed.length
            while (i < l) {
                var count = packed[i++].toInt()
                val value = packed[i++].toInt()
                do result[j++] = value while (--count > 0)
            }
            return j
        }

        /**
         * Translates a state to a row index in the transition table
         */
        private val ZZ_ROWMAP = zzUnpackRowMap()
        private const val ZZ_ROWMAP_PACKED_0 =
            "\u0000\u0000\u0000\u0015\u0000\u002a\u0000\u003f\u0000\u0054\u0000\u0069\u0000\u007e\u0000\u0093" +
                    "\u0000\u00a8\u0000\u00bd\u0000\u00d2\u0000\u00e7\u0000\u00fc\u0000\u0111\u0000\u0126\u0000\u013b" +
                    "\u0000\u0150\u0000\u0165\u0000\u017a\u0000\u018f\u0000\u01a4\u0000\u01b9\u0000\u01ce\u0000\u01e3" +
                    "\u0000\u01f8\u0000\u020d\u0000\u0222\u0000\u0237\u0000\u024c\u0000\u0261\u0000\u0276\u0000\u028b" +
                    "\u0000\u02a0\u0000\u02b5\u0000\u02ca\u0000\u02df\u0000\u02f4\u0000\u00bd\u0000\u0309\u0000\u031e" +
                    "\u0000\u0333\u0000\u0348\u0000\u035d\u0000\u0372\u0000\u0387\u0000\u039c"

        private fun zzUnpackRowMap(): IntArray {
            val result = IntArray(46)
            var offset = 0
            offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result)
            return result
        }

        private fun zzUnpackRowMap(packed: String, offset: Int, result: IntArray): Int {
            var i = 0 /* index in packed string  */
            var j = offset /* index in unpacked array */
            val l = packed.length
            while (i < l) {
                val high = packed[i++].toInt() shl 16
                result[j++] = high or packed[i++].toInt()
            }
            return j
        }

        /**
         * The transition table of the DFA
         */
        private val ZZ_TRANS = zzUnpackTrans()
        private const val ZZ_TRANS_PACKED_0 =
            "\u0001\u000a\u0001\u000b\u0002\u000a\u0001\u000c\u0006\u000a\u0001\u000d\u0001\u000a\u0001\u000e" +
                    "\u0002\u000a\u0001\u000f\u0001\u0010\u0001\u0011\u0001\u0012\u0011\u000a\u0001\u000f\u0001\u0010" +
                    "\u0001\u0011\u0001\u0012\u0002\u000a\u0001\u000b\u0002\u000a\u0001\u000c\u0006\u000a\u0001\u000d" +
                    "\u0001\u000a\u0001\u0013\u0002\u000a\u0001\u000f\u0001\u0010\u0001\u0011\u0001\u0012\u0001\u000a" +
                    "\u000e\u0014\u0001\u0015\u0001\u0016\u0001\u000f\u0001\u0010\u0001\u0011\u0001\u0017\u0001\u0018" +
                    "\u000e\u0014\u0001\u0015\u0001\u0019\u0001\u000f\u0001\u0010\u0001\u0011\u0001\u0017\u0001\u0018" +
                    "\u000e\u0014\u0001\u001a\u0001\u0014\u0001\u000f\u0001\u0010\u0001\u0011\u0001\u0017\u0001\u0018" +
                    "\u000e\u001b\u0001\u001a\u0001\u001b\u0001\u000f\u0001\u0010\u0001\u0011\u0001\u001c\u0001\u001b" +
                    "\u0011\u001d\u0001\u0010\u0001\u0011\u0001\u001c\u0001\u001d\u0011\u0014\u0001\u0010\u0001\u0011" +
                    "\u0001\u0017\u0001\u0018\u0011\u000a\u0002\u0000\u0004\u000a\u0001\u001e\u000e\u000a\u0002\u0000" +
                    "\u0007\u000a\u0001\u001f\u0001\u000a\u0001\u001e\u0001\u0020\u0008\u000a\u0002\u0000\u0004\u000a" +
                    "\u0001\u0021\u000e\u000a\u0002\u0000\u000f\u000a\u0001\u0022\u0003\u000a\u0002\u0000\u0002\u000a" +
                    "\u0011\u000f\u0002\u0000\u0002\u000f\u0026\u0000\u0001\u0010\u0003\u0000\u0011\u000a\u0002\u0000" +
                    "\u0001\u0012\u000e\u000a\u0001\u0023\u0003\u000a\u0002\u0000\u0002\u000a\u0011\u0014\u0002\u0000" +
                    "\u0002\u0014\u0011\u0015\u0002\u0000\u0002\u0015\u0011\u0016\u0002\u0000\u0002\u0016\u0013\u0000" +
                    "\u0001\u0017\u0001\u0024\u0011\u0014\u0002\u0000\u0001\u0014\u0001\u0025\u0011\u0019\u0002\u0000" +
                    "\u0002\u0019\u0011\u001a\u0002\u0000\u0002\u001a\u0011\u001b\u0002\u0000\u0002\u001b\u0013\u0000" +
                    "\u0001\u001c\u0001\u0000\u0011\u001d\u0002\u0000\u0002\u001d\u0003\u000a\u0001\u0026\u000d\u000a" +
                    "\u0002\u0000\u0008\u000a\u0001\u001e\u000a\u000a\u0002\u0000\u0005\u000a\u0001\u0027\u000d\u000a" +
                    "\u0002\u0000\u000e\u000a\u0001\u0028\u0004\u000a\u0002\u0000\u0002\u000a\u0011\u0022\u0002\u0000" +
                    "\u0002\u0022\u0011\u0023\u0002\u0000\u0002\u0023\u0014\u0000\u0001\u0029\u0011\u0014\u0002\u0000" +
                    "\u0001\u0014\u0001\u002a\u0009\u000a\u0001\u002b\u0007\u000a\u0002\u0000\u0004\u000a\u0001\u002c" +
                    "\u000e\u000a\u0002\u0000\u0002\u000a\u0014\u0000\u0001\u002d\u0011\u0014\u0002\u0000\u0001\u002a" +
                    "\u0001\u0014\u000a\u000a\u0001\u0026\u0006\u000a\u0002\u0000\u0005\u000a\u0001\u002e\u000d\u000a" +
                    "\u0002\u0000\u0002\u000a\u0013\u0000\u0001\u002d\u0001\u0000\u0002\u000a\u0001\u0026\u000e\u000a" +
                    "\u0002\u0000\u0002\u000a"

        private fun zzUnpackTrans(): IntArray {
            val result = IntArray(945)
            var offset = 0
            offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result)
            return result
        }

        private fun zzUnpackTrans(packed: String, offset: Int, result: IntArray): Int {
            var i = 0 /* index in packed string  */
            var j = offset /* index in unpacked array */
            val l = packed.length
            while (i < l) {
                var count = packed[i++].toInt()
                var value = packed[i++].toInt()
                value--
                do result[j++] = value while (--count > 0)
            }
            return j
        }

        /* error codes */
        private const val ZZ_UNKNOWN_ERROR = 0
        private const val ZZ_NO_MATCH = 1
        private const val ZZ_PUSHBACK_2BIG = 2

        /* error messages for the codes above */
        private val ZZ_ERROR_MSG = arrayOf(
            "Unknown internal scanner error",
            "Error: could not match input",
            "Error: pushback value was too large"
        )

        /**
         * ZZ_ATTRIBUTE[aState] contains the attributes of state `aState`
         */
        private val ZZ_ATTRIBUTE = zzUnpackAttribute()
        private const val ZZ_ATTRIBUTE_PACKED_0 =
            "\u0009\u0000\u0006\u0001\u0001\u0009\u0013\u0001\u0001\u0000\u0004\u0001\u0001\u0000\u0005\u0001"

        private fun zzUnpackAttribute(): IntArray {
            val result = IntArray(46)
            var offset = 0
            offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result)
            return result
        }

        private fun zzUnpackAttribute(packed: String, offset: Int, result: IntArray): Int {
            var i = 0 /* index in packed string  */
            var j = offset /* index in unpacked array */
            val l = packed.length
            while (i < l) {
                var count = packed[i++].toInt()
                val value = packed[i++].toInt()
                do result[j++] = value while (--count > 0)
            }
            return j
        }

        /**
         * Unpacks the compressed character translation table.
         *
         * @param packed   the packed character translation table
         * @return         the unpacked character translation table
         */
        private fun zzUnpackCMap(packed: String): CharArray {
            var size = 0
            run {
                var i = 0
                val length = packed.length
                while (i < length) {
                    size += packed[i].toInt()
                    i += 2
                }
            }
            val map = CharArray(size)
            var i = 0 /* index in packed string  */
            var j = 0 /* index in unpacked array */
            while (i < packed.length) {
                var count = packed[i++].toInt()
                val value = packed[i++]
                do map[j++] = value while (--count > 0)
            }
            return map
        }
    }
}